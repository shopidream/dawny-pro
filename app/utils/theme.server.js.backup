import { authenticate } from "../shopify.server.js";

import { 
  obfuscateCSS, 
  obfuscateLiquid, 
  generateDailyKey,
  generateRestoreCSS 
} from "./obfuscation.server.js";

// Get list of themes from Shopify
export async function getThemes(request) {
  try {
    const { admin } = await authenticate.admin(request);
    
    const response = await admin.graphql(`
      query {
        themes(first: 50) {
          nodes {
            id
            name
            role
            processing
            createdAt
            updatedAt
          }
        }
      }
    `);
    
    const data = await response.json();
    
    if (data.errors) {
      console.error('GraphQL errors:', data.errors);
      return [];
    }
    
    return data.data.themes.nodes;
  } catch (error) {
    console.error('Error fetching themes:', error);
    return [];
  }
}

// Debug authentication structure
export async function debugAuth(request) {
  try {
    const authResult = await authenticate.admin(request);
    
    console.log('=== FULL AUTH DEBUG ===');
    console.log('Auth result keys:', Object.keys(authResult));
    
    if (authResult.admin) {
      console.log('Admin keys:', Object.keys(authResult.admin));
    }
    
    if (authResult.session) {
      console.log('Session keys:', Object.keys(authResult.session));
      console.log('Session shop:', authResult.session.shop);
      console.log('Session accessToken exists:', !!authResult.session.accessToken);
    }
    
    // Try to get shop info via GraphQL
    const shopResponse = await authResult.admin.graphql(`
      query {
        shop {
          name
          myshopifyDomain
        }
      }
    `);
    
    const shopData = await shopResponse.json();
    console.log('Shop from GraphQL:', shopData.data?.shop);
    
    return authResult;
  } catch (error) {
    console.error('Auth debug error:', error);
    throw error;
  }
}

// Get theme.liquid content
export async function getThemeLiquid(request, themeId) {
  try {
    const authResult = await authenticate.admin(request);
    
    let shop, accessToken;
    if (authResult.session) {
      shop = authResult.session.shop;
      accessToken = authResult.session.accessToken;
    } else if (authResult.admin && authResult.admin.session) {
      shop = authResult.admin.session.shop;
      accessToken = authResult.admin.session.accessToken;
    }
    
    const numericThemeId = themeId.replace('gid://shopify/OnlineStoreTheme/', '');
    const url = `https://${shop}/admin/api/2023-10/themes/${numericThemeId}/assets.json?asset[key]=layout/theme.liquid`;
    
    const response = await fetch(url, {
      method: 'GET',
      headers: {
        'X-Shopify-Access-Token': accessToken,
        'Content-Type': 'application/json',
      }
    });
    
    if (!response.ok) {
      throw new Error(`Failed to get theme.liquid: ${response.status}`);
    }
    
    const result = await response.json();
    return result.asset.value;
  } catch (error) {
    console.error('Error getting theme.liquid:', error);
    throw error;
  }
}

// Update theme.liquid with CSS link
export async function updateThemeLiquid(request, themeId, cssFileName, action = 'add') {
  try {
    const authResult = await authenticate.admin(request);
    
    let shop, accessToken;
    if (authResult.session) {
      shop = authResult.session.shop;
      accessToken = authResult.session.accessToken;
    } else if (authResult.admin && authResult.admin.session) {
      shop = authResult.admin.session.shop;
      accessToken = authResult.admin.session.accessToken;
    }
    
    // Get current theme.liquid content
    const currentContent = await getThemeLiquid(request, themeId);
    
    // Create CSS link
    const cssLink = `{{ "${cssFileName}" | asset_url | stylesheet_tag }}`;
    const cssComment = `<!-- Dawny Pro CSS -->`;
    const fullCssBlock = `  ${cssComment}\n  ${cssLink}`;
    
    let updatedContent;
    
    if (action === 'add') {
      // Check if CSS is already included
      if (currentContent.includes(cssLink)) {
        console.log('CSS already included in theme.liquid');
        return { success: true, message: 'CSS already included', action: 'skipped' };
      }
      
      // Add CSS link before </head>
      if (currentContent.includes('</head>')) {
        updatedContent = currentContent.replace('</head>', `${fullCssBlock}\n</head>`);
      } else {
        throw new Error('Could not find </head> tag in theme.liquid');
      }
    } else if (action === 'remove') {
      // Remove CSS link and comment
      if (!currentContent.includes(cssLink)) {
        console.log('CSS not found in theme.liquid');
        return { success: true, message: 'CSS not found', action: 'skipped' };
      }
      
      // Remove the CSS block
      updatedContent = currentContent
        .replace(new RegExp(`\\s*${cssComment}\\s*\n?`, 'g'), '')
        .replace(new RegExp(`\\s*${cssLink.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\s*\n?`, 'g'), '');
    }
    
    // Save updated theme.liquid
    const numericThemeId = themeId.replace('gid://shopify/OnlineStoreTheme/', '');
    const url = `https://${shop}/admin/api/2023-10/themes/${numericThemeId}/assets.json`;
    
    const response = await fetch(url, {
      method: 'PUT',
      headers: {
        'X-Shopify-Access-Token': accessToken,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        asset: {
          key: 'layout/theme.liquid',
          value: updatedContent
        }
      })
    });
    
    if (!response.ok) {
      throw new Error(`Failed to update theme.liquid: ${response.status}`);
    }
    
    console.log(`Successfully ${action}ed CSS in theme.liquid`);
    return { 
      success: true, 
      message: `CSS ${action}ed successfully`, 
      action: action 
    };
  } catch (error) {
    console.error('Error updating theme.liquid:', error);
    throw error;
  }
}

// Delete file from theme
export async function deleteFileFromTheme(request, themeId, filePath) {
  try {
    const authResult = await authenticate.admin(request);
    
    let shop, accessToken;
    if (authResult.session) {
      shop = authResult.session.shop;
      accessToken = authResult.session.accessToken;
    } else if (authResult.admin && authResult.admin.session) {
      shop = authResult.admin.session.shop;
      accessToken = authResult.admin.session.accessToken;
    }
    
    const numericThemeId = themeId.replace('gid://shopify/OnlineStoreTheme/', '');
    const url = `https://${shop}/admin/api/2023-10/themes/${numericThemeId}/assets.json?asset[key]=${filePath}`;
    
    console.log(`Deleting file: ${filePath} from theme ${numericThemeId}`);
    
    const response = await fetch(url, {
      method: 'DELETE',
      headers: {
        'X-Shopify-Access-Token': accessToken,
        'Content-Type': 'application/json',
      }
    });
    
    if (!response.ok) {
      const errorText = await response.text();
      console.error('Delete failed:', response.status, errorText);
      throw new Error(`Delete failed: ${response.status} ${errorText}`);
    }
    
    console.log(`Successfully deleted: ${filePath}`);
    return { 
      success: true, 
      filePath 
    };
  } catch (error) {
    console.error(`Error deleting file:`, error);
    throw error;
  }
}

// Upload file using fetch API with proper session handling
export async function uploadFileToTheme(request, themeId, fileName, fileContent, fileType = 'asset') {
  try {
    // Get authentication details properly
    const authResult = await debugAuth(request);
    
    // Extract numeric theme ID from GraphQL ID
    const numericThemeId = themeId.replace('gid://shopify/OnlineStoreTheme/', '');
    
    // Determine file path based on type
    let filePath;
    switch (fileType) {
      case 'style':
        filePath = `assets/${fileName}`;
        break;
      case 'section':
        filePath = `sections/${fileName}`;
        break;
      case 'template':
        filePath = `templates/${fileName}`;
        break;
      case 'layout':
        filePath = `layout/${fileName}`;
        break;
      default:
        filePath = `assets/${fileName}`;
    }
    
    console.log(`Uploading ${fileType} to ${filePath} on theme ${numericThemeId}`);
    
    // Get shop and access token from the correct location
    let shop, accessToken;
    
    if (authResult.session) {
      shop = authResult.session.shop;
      accessToken = authResult.session.accessToken;
    } else if (authResult.admin && authResult.admin.session) {
      shop = authResult.admin.session.shop;
      accessToken = authResult.admin.session.accessToken;
    } else {
      throw new Error('Could not find shop or access token in auth result');
    }
    
    console.log('Using shop:', shop);
    console.log('Access token exists:', !!accessToken);
    
    if (!shop || !accessToken) {
      throw new Error('Missing shop or access token');
    }
    
    const url = `https://${shop}/admin/api/2023-10/themes/${numericThemeId}/assets.json`;
    
    console.log('Making request to:', url);
    
    const response = await fetch(url, {
      method: 'PUT',
      headers: {
        'X-Shopify-Access-Token': accessToken,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        asset: {
          key: filePath,
          value: fileContent
        }
      })
    });
    
    console.log('Response status:', response.status);
    
    if (!response.ok) {
      const errorText = await response.text();
      console.error('Upload failed:', response.status, errorText);
      throw new Error(`Upload failed: ${response.status} ${errorText}`);
    }
    
    const result = await response.json();
    console.log('Upload successful:', result);
    
    return { 
      success: true, 
      fileName, 
      filePath: result.asset.key, 
      size: result.asset.size 
    };
  } catch (error) {
    console.error(`Error uploading ${fileType}:`, error);
    throw error;
  }
}

// Install theme package with SMART OBFUSCATION
export async function installThemePackage(request, themeId, cssContent, sectionContent, selectedTheme) {
  try {
    console.log('=== 🔐 SMART OBFUSCATION INSTALLATION STARTING ===');
    console.log('Theme ID:', themeId);
    console.log('Has CSS:', !!cssContent);
    console.log('Has Section:', !!sectionContent);
    
    let results = [];
    const dailyKey = generateDailyKey();
    
    console.log('Generated daily key:', dailyKey);
    
    // Upload CSS if provided (OBFUSCATED VERSION)
    if (cssContent && themeId) {
      try {
        console.log('🎨 Processing CSS with smart obfuscation...');
        
        // CSS 난독화 (디자인 망가뜨리기)
        const obfuscatedCSS = obfuscateCSS(cssContent);
        console.log('Obfuscated CSS length:', obfuscatedCSS.length);
        
        // 난독화된 CSS 업로드
        const cssResult = await uploadFileToTheme(request, themeId, 'style-luxury-v1.css', obfuscatedCSS, 'style');
        console.log('CSS upload result:', cssResult);
        results.push(`CSS uploaded (obfuscated): ${cssResult.filePath}`);
        
        // Auto-link CSS to theme.liquid
        console.log('🔗 Linking CSS to theme.liquid...');
        const linkResult = await updateThemeLiquid(request, themeId, 'style-luxury-v1.css', 'add');
        results.push(`CSS linked: ${linkResult.message}`);
        
      } catch (error) {
        console.error('CSS processing failed:', error.message);
        results.push(`CSS failed: ${error.message}`);
        throw error;
      }
    }
    
    // Upload section if provided (OBFUSCATED VERSION)
    if (sectionContent && themeId) {
      try {
        console.log('📄 Processing Section with smart obfuscation...');
        
        // Liquid 안전 난독화
        const obfuscatedLiquid = obfuscateLiquid(sectionContent);
        console.log('Obfuscated Liquid length:', obfuscatedLiquid.length);
        
        // 난독화된 섹션 업로드
        const sectionResult = await uploadFileToTheme(request, themeId, 'shoppable-video.liquid', obfuscatedLiquid, 'section');
        console.log('Section upload result:', sectionResult);
        results.push(`Section uploaded (obfuscated): ${sectionResult.filePath}`);
        
      } catch (error) {
        console.error('Section processing failed:', error.message);
        results.push(`Section failed: ${error.message}`);
        throw error;
      }
    }
    
    console.log('=== 🎉 SMART OBFUSCATION INSTALLATION COMPLETE ===');
    
    return {
      success: true,
      message: `Smart installation completed: ${results.join(', ')}`,
      details: {
        css: cssContent ? "Obfuscated & Protected" : "Not provided",
        section: sectionContent ? "Obfuscated & Protected" : "Not provided",
        license: `Generated key: ${dailyKey.slice(-8)}...`,
        results: results
      }
    };
  } catch (error) {
    console.error('Smart installation error:', error);
    return {
      success: false,
      message: `Smart installation failed: ${error.message}`
    };
  }
}

// Remove theme package
export async function removeThemePackage(request, themeId, packageType) {
  try {
    console.log('=== REMOVAL STARTING ===');
    console.log('Theme ID:', themeId);
    console.log('Package Type:', packageType);
    
    let results = [];
    
    if (packageType === 'css' || packageType === 'all') {
      try {
        // Remove CSS link from theme.liquid first
        console.log('Removing CSS link from theme.liquid...');
        const unlinkResult = await updateThemeLiquid(request, themeId, 'style-luxury-v1.css', 'remove');
        results.push(`CSS unlinked: ${unlinkResult.message}`);
        
        // Delete CSS file
        console.log('Deleting CSS file...');
        const deleteResult = await deleteFileFromTheme(request, themeId, 'assets/style-luxury-v1.css');
        results.push(`CSS deleted: ${deleteResult.filePath}`);
        
      } catch (error) {
        console.error('CSS removal failed:', error.message);
        results.push(`CSS removal failed: ${error.message}`);
      }
    }
    
    if (packageType === 'section' || packageType === 'all') {
      try {
        // Delete section file
        console.log('Deleting section file...');
        const deleteResult = await deleteFileFromTheme(request, themeId, 'sections/shoppable-video.liquid');
        results.push(`Section deleted: ${deleteResult.filePath}`);
        
      } catch (error) {
        console.error('Section removal failed:', error.message);
        results.push(`Section removal failed: ${error.message}`);
      }
    }
    
    return {
      success: true,
      message: `Removal completed: ${results.join(', ')}`,
      details: {
        results: results
      }
    };
  } catch (error) {
    console.error('Removal error:', error);
    return {
      success: false,
      message: `Removal failed: ${error.message}`
    };
  }
}

// Get installation info (placeholder)
export async function getInstallationInfo(request) {
  return {
    currentStatus: null,
    history: [],
    hasInstallation: false
  };
}
